/* pitchentry.c
 *  responses to pitchrecognition from audio in
 *
 * for Denemo, a gtk+ frontend to GNU Lilypond
 * (c)2007 Richard Shann
 */
#include <math.h>
#include "audio.h"
#include "pitchentry.h"
#include "view.h"


#define  DEFAULT_HIGH (4500.0)
#define  DEFAULT_LOW (60.0)
#define DEFAULT_TIMER_RATE (50)


static GtkWidget *PR_window = NULL;/* a top level window for controlling pitch-recognition entry.
			      We do not create one of these for each view (ie each DenemoGUI object, ie each score) because there is only one audio input source being used, so we would have to cope with resource contention issues, there is just no point. */
static DenemoGUI *PR_gui; /* the gui for which the pitch recognition has been set up */
static gboolean PR_insert; /* whether the notes should be inserted directly in the score or put in a list for controlled insertion */
static gboolean PR_continuous; /* whether to go on to the next measure once overlay for current measure is full */
gint PR_click;/*volume of a audible warning of next measure or extra tones in measure */
static GtkWidget *PR_notelabel = NULL;
static GtkWidget *PR_deviation = NULL;
static guint PR_timer;// timer id
static guint PR_enter;// signal id
static guint PR_leave;// signal id
//keymap *PR_oldkeymap;// the keymap of PR_gui when PR was started
//keymap *PR_rhythmkeymap;// special keymap for rhythm work.

static guint PR_time = DEFAULT_TIMER_RATE;//the period of timer for checking for a new pitch in ms 10 gives quicker response,100 more reliability... 
gboolean PR_enable = TRUE;
guint greatest_interval;
static gdouble lowest_pitch = DEFAULT_LOW;
static gdouble highest_pitch = DEFAULT_HIGH;
static gboolean repeated_notes_allowed;
static gdouble transposition_required = 1.0;
typedef struct notespec {
  guint step;  /* 0=C 1=D ... 6=B */
  gint alteration; /* -2 = bb, -1=b, 0=natural, 1=#, 2=x */
} notespec;

typedef struct notepitch {

  double pitch; /* pitch of note of given notespec in range C=260 to B=493 Hz
		 actual pitch is *=2^octave   */
  notespec spec;
} notepitch;

typedef struct temperament {
  gchar *name;
  gint sharp;/* which notepitch is the sharpest in circle of 5ths - initially G# */
  gint flat;/* which notepitch is the flattest in circle of 5ths - initially Eb */
  notepitch notepitches[12]; /* pitches of C-natural, C#, ... A#, B-natural */
} temperament;

#if 0
Pythagorean
261.6	279.4	294.3 	310.1	331.1	348.8 	372.5	392.4	419.1 	441.5	465.1	496.7
Van Zwolle
261.6	279.4	294.3 	314.3	331.1	353.6 	372.5	392.4	419.1 	441.5	471.5	496.7
Meantone
261.6	272.8	292.3 	313.2	326.7	350.0 	365.0	391.1	407.9 	437.0	468.3	488.3
Silbermann I
261.6	275.0	293.0 	312.2	328.1	349.6 	367.5	391.6	411.6 	438.5	467.2	491.1
Silbermann II
261.6	276.2	293.0 	312.2	329.6	349.6 	369.2	391.6	413.4 	438.5	467.2	493.3
Rameau
261.6	276.9	293.3 	309.7	330.4	348.8 	369.2	391.1	413.9 	438.5	463.0	493.9
Werckmeister III
261.6	277.5	293.3 	311.1	328.9	350.0 	370.0	391.1	414.8 	438.5	466.7	493.3
Werckmeister IV
261.6	275.6	293.0 	311.5	329.6	348.8 	369.2	390.7	413.4 	437.5	467.2	492.2
Werckmeister V
261.6	275.6	293.3 	311.1	328.9	348.8 	368.7	392.4	413.4 	438.5	465.1	493.3
Werckmeister VI
261.6	278.3	293.8 	311.3	331.1	349.5 	372.5	391.7	414.2 	441.5	466.9	496.7
Kirnberger II
261.6	277.5	294.3 	312.2	328.9	348.8 	370.0	392.4	416.2 	438.5	465.1	493.3
Kirnberger III
261.6	277.5	293.3 	311.1	328.9	348.8 	370.0	391.1	414.8 	438.5	465.1	493.3
Italian 18th Century
261.6	277.2	293.0 	311.1	328.9	349.2 	370.0	391.1	414.4 	438.0	465.1	492.8
Equal Temperament
261.6	277.2	293.7 	311.1	329.6	349.2 	370.0	392.0	415.3 	440.0	466.2	493.9
HARPSICHORD TUNING - A COURSE OUTLINE, by G.C. Klop, distributed by The Sunbury Press, P.O. Box 1778, Raleigh, NC 27602.
#endif
static temperament Equal = {
  "Equal Temperament", 8,3,
    { 
      {261.6, {0, 0}},
      {277.2, {0, 1}},
      {293.7, {1, 0}},
      {311.1, {2, -1}},
      {329.6, {2, 0}},
      {349.2, {3, 0}},
      {370.0, {3, 1}},
      {392.0, {4, 0}},
      {415.3, {4, 1}},
      {440.0, {5, 0}},
      {466.2, {6, -1}},
      {493.9, {6, 0}}
  }
};

 

static temperament Meantone = {
  "Quarter comma meantone", 8,3,
    { 
      {261.6, {0, 0}},
      {272.8, {0, 1}},
      {292.3, {1, 0}},
      {313.2, {2, -1}},
      {326.7, {2, 0}},
      {350.0, {3, 0}},
      {365.0, {3, 1}},
      {391.1, {4, 0}},
      {407.9, {4, 1}},
      {437.0, {5, 0}},
      {468.3, {6, -1}},
      {488.3, {6, 0}}
  }
};


static temperament WerkmeisterIV = {
  "Werkmeister IV", 8,3,
    { 
      {262.513, {0, 0}}, /* c */
      {274.070, {0, 1}},
      {293.997, {1, 0}}, /* d */
      {311.830, {2, -1}},/* Eb */
      {329.256, {2, 0}}, /* e */
      {350.809, {3, 0}}, /* f */
      {365.427, {3, 1}},
      {392.882, {4, 0}}, /* g */
      {410.641, {4, 1}},/* g# */
      {440.000, {5, 0}}, /* a */
      {467.218, {6, -1}}, /* Bb */
      {493.883, {6, 0}}/* b */
  }
};

static temperament *PR_temperament; /* the currently used temperament */



static void pr_display_note(DenemoGUI*gui, gchar *notename) {
  gchar *labelstr = g_strdup_printf("<span foreground=\"black\" font_desc=\"48\">%s</span>",notename);
  //printf("string is %s\n", labelstr);
  gtk_label_set_markup(GTK_LABEL(PR_notelabel), labelstr);
  g_free(labelstr);
}

static void pr_display_pitch_deviation(DenemoGUI*gui, double deviation) {
  gchar *labelstr = g_strdup_printf("<span foreground=\"%s\" font_desc=\"48\">%2.1f</span>",deviation>0.0?"blue":deviation<0.0?"red":"black", deviation);
  gtk_label_set_markup(GTK_LABEL(PR_deviation),labelstr );
  g_free(labelstr);
}



/* return c,d,e,f,g,a,b depending on the step. German translation will
   be difficult I'm afraid. */
static gchar step_name(guint step) {
  if(step>4)
    step -= 7;
  return 'C'+step;


}

/* return "##", "#" ..."  "..... "bb" for double sharp to double flat accidentals
 a const string is returned*/
static gchar *alteration_name(gint alteration) {
  switch(alteration) {
  case -2:
    return "bb";
  case -1:
    return "b";
  case 0:
    return "";
  case 1:
    return "#";

  case 2:
    return "##";
  default:
    return "ER";
  }
}




/* returns the note names currently set for the given temperament
 caller must free the string */
static gchar * notenames(gpointer p) {
  temperament *t=(temperament*)p;
  gchar *str, *oldstr;
  gint i;
  oldstr = g_strdup("");
  for(i=0;i<12;i++) {
    if(i==t->flat)
      str = g_strdup_printf("%s<span size=\"large\" foreground=\"red\">%c%s</span> ", oldstr, step_name(t->notepitches[i].spec.step), alteration_name(t->notepitches[i].spec.alteration));
    else
    if(i==t->sharp)
       str = g_strdup_printf("%s<span size=\"large\" foreground=\"blue\">%c%s</span> ", oldstr, step_name(t->notepitches[i].spec.step), alteration_name(t->notepitches[i].spec.alteration));
    else
      str = g_strdup_printf("%s%c%s ", oldstr, step_name(t->notepitches[i].spec.step), alteration_name(t->notepitches[i].spec.alteration));
    g_free(oldstr);
    oldstr = str;
  }
  return str;
}


/* returns an opaque id for the user's default temperament
 FIXME user prefs */
static gpointer default_temperament() {
  return (gpointer) &Equal;
}


static void sharpen(GtkButton *button, GtkWidget *label) {
#define f  (PR_temperament->notepitches[PR_temperament->flat].spec)
  gint next = (PR_temperament->flat+11)%12;
#define g (PR_temperament->notepitches[next].spec)
 if(g.alteration+1>2) 
  return;
 else  {
     f.step = g.step;

      f.alteration =   g.alteration+1;

  }
#undef f
#undef g
  PR_temperament->sharp = PR_temperament->flat;
  PR_temperament->flat = (PR_temperament->flat+7)%12;
  gchar *names = notenames(PR_temperament);
  gtk_label_set_markup((GtkLabel*)label, names);
  g_free(names);
  return;
}




static void flatten(GtkButton *button, GtkWidget *label) {

#define s (PR_temperament->notepitches[PR_temperament->sharp].spec)
  gint next = (PR_temperament->sharp+1)%12;
#define t (PR_temperament->notepitches[next].spec)
if(t.alteration-1<-2) 
  return;
 else {
   s.step = t.step;
   s.alteration =  t.alteration-1;  
 }
#undef s
#undef t
  PR_temperament->flat = PR_temperament->sharp;
  PR_temperament->sharp = (PR_temperament->sharp+5)%12;
  gchar *names = notenames(PR_temperament);
  gtk_label_set_markup((GtkLabel*)label, names);
  g_free(names);
  return;
}


static void sound_click(void) {
  if(PR_click)
    gdk_beep();
}

static GList *get_tones(GList *tone_store, gint measurenum) {
  GList *g = g_list_nth(tone_store, measurenum);
  if(g)
    return g->data;
  return NULL;
}

/* apply the tones in the currentmeasure to the notes of the currentmeasure */

static gboolean  apply_tones(DenemoScore *si) { 
  gboolean ret=FALSE;
#define curstaff ((DenemoStaff*)si->currentstaff->data)
  GList *store;
  gint measurenum;
  store  = (curstaff->tone_store);
  measurenode *curmeasure = curstaff->measures;
  GList *store_el = NULL;

  measurenum =  si->currentmeasurenum - 1;
  curmeasure = si->currentmeasure;
  if(curmeasure) {
    store_el = get_tones(store, measurenum);
    objnode *curobj = curmeasure->data;
    for (; curobj && store_el; curobj = curobj->next)
      {
	tone* thetone;
	while(store_el && (thetone = (tone*)store_el->data) &&
	      !thetone->valid)
	  store_el = store_el->next;
	
	DenemoObject *theobj = (DenemoObject *) curobj->data;
	if(theobj->type == CHORD && ((chord*)theobj->object)->notes /* not a rest */) {
	  find_leftmost_staffcontext (curstaff, si);
	  if(thetone==NULL || store_el==NULL)
	    ((chord*)theobj->object)->tone_node = NULL;
	  else {
	    int dclef = curstaff->leftmost_clefcontext;	    
	    int mid_c_offset = thetone->step;
	    ((chord*)theobj->object)->tone_node = store_el;
	    modify_note(((chord*)theobj->object)->notes->data, mid_c_offset, thetone->enshift, dclef);
	    ((chord *) theobj->object)->sum_mid_c_offset = mid_c_offset;//Damned difficult to track this down - will not work if there are >1 notes in chord
	    ((chord *) theobj->object)->highestpitch = mid_c_offset;
	    ((chord *) theobj->object)->highesty =
	      calculateheight (mid_c_offset, dclef);
	    ((chord *) theobj->object)->lowestpitch = mid_c_offset;
	    ((chord *) theobj->object)->lowesty =
	      calculateheight (mid_c_offset, dclef);
	    store_el = store_el->next;
	  }// tone available
	}// note available
	if(curobj->next==NULL && curmeasure->next)
	 ret = TRUE;
      }// for objects in measure
    if(store_el && !PR_continuous) 
      sound_click();//extra tones in measure
    showwhichaccidentals ((objnode *) si->currentmeasure->data,
			  si->curmeasurekey, si->curmeasureaccs);
  }
  return ret;
}


/*
 * enter_note_in_score
 * enters the note FOUND in the score gui->si at octave OCTAVE steps above/below mid-c
 */
static void enter_note_in_score (DenemoGUI *gui, notepitch * found, gint octave) {
  //printf("Cursor_y %d and staffletter = %d\n", gui->si->cursor_y, gui->si->staffletter_y);
  gui->si->cursor_y = gui->si->staffletter_y = found->spec.step;
  gui->si->cursor_y += 7*octave;
  shiftcursor(gui, found->spec.step);
  setenshift(gui->si, found->spec.alteration);
  displayhelper (gui);
}





static GList * put_tone(GList *store, gint measurenum, tone *thetone) {
  // extend store if too small
  gint i = measurenum + 1 - g_list_length(store);
  for(;i>0;i--) {
    store = g_list_append(store,NULL);
  }
  GList *g = g_list_nth(store, measurenum);
  if(g)
    g->data = g_list_append(g->data, thetone);
  return store;
}


/*
 * enter_tone_in_store
 * enters the note FOUND as a tone in the tone store
 */
static void enter_tone_in_store (DenemoGUI *gui, notepitch * found, gint octave) {
  gboolean nextmeasure;
  tone *thetone = (tone*)g_malloc0(sizeof(tone));
  //g_print("tone %p\n", thetone);
  thetone->enshift = found->spec.alteration;
  thetone->step = found->spec.step + 7*octave;
  thetone->octave = octave;
  thetone->valid = TRUE;
#define store  (((DenemoStaff*)gui->si->currentstaff->data)->tone_store)
  store = put_tone(store, gui->si->currentmeasurenum - 1, thetone);
  nextmeasure = apply_tones(gui->si);
  displayhelper (gui);
  if(PR_continuous && nextmeasure) {
    sound_click();
    measureright(gui);
  }
  
  /* gtk_widget_draw(gui->scorearea, NULL); */
#undef store
}


static void clear_tone_nodes(DenemoGUI *gui ) {
  // FIXME menory leak, free the curstaff->tone_store
  DenemoScore *si = gui->si;
#define curstaff ((DenemoStaff*)si->currentstaff->data)
  measurenode *curmeasure;
  for (curmeasure = curstaff->measures;curmeasure; curmeasure = curmeasure->next) {
    objnode *curobj = curmeasure->data;
    for (; curobj; curobj = curobj->next)
      {
	DenemoObject *theobj = (DenemoObject *) curobj->data;
	if(theobj->type == CHORD) {
	   ((chord*)theobj->object)->tone_node = NULL;
	}
      }
  }
}

static void free_tones(GList *tones) {
  if(tones){
    g_list_foreach(tones,freeit,NULL);
    g_list_free(tones);
  }
}

  // clear gui->si->currentstaff->data->tone_store
static void clear_tone_store(GtkButton *button, DenemoGUI *gui ) {
#define store  (((DenemoStaff*)gui->si->currentstaff->data)->tone_store)

  g_list_foreach (store, free_tones, NULL);
  clear_tone_nodes(gui);
  g_list_free(store);
  store = NULL;
#undef store
  displayhelper(gui);
}


gboolean delete_tone(DenemoScore *si, chord *thechord) {
  GList *tone_node = thechord->tone_node;
  if(tone_node) {
    ((tone*)tone_node->data)->valid = FALSE;
    thechord->tone_node = NULL;
  apply_tones(si);
  displayhelper (PR_gui);
  return TRUE;
  } else {
    return FALSE;
  }

}

/* return note for the passed pitch, or NULL if not a good note;
 * @param pitch, the pitch being enquired about
 * @temperament, the temperament to use to determine which pitch.
 * @param which_octave returns the number of the octave above/below mid_c
FIXME there is a bug when the enharmonic changes take b# into the wrong octave
*/
static notepitch * determine_note(gdouble pitch, temperament *t, gint* which_octave, double *deviation) {
  gint i;
  gint octave = 0;
  while(pitch > t->notepitches[11].pitch*(1.0231)/* quartertone */) {
    //printf("pitch going down %f pitch %f\n", pitch, t->notepitches[11].pitch*(1.0231) );
    pitch /= 2;
    octave++;
  }
  while(pitch < t->notepitches[0].pitch*(0.977)/* quartertone */) {
    //printf("pitch going up %f pitch\n", pitch);
    pitch *=2;
    octave--;
  }
  for(i=0;i<12;i++) {
    //printf("considering %d %f\n", pitch, t->notepitches[i].pitch);
    if((pitch > t->notepitches[i].pitch*(0.977)) &&
       (pitch <= t->notepitches[i].pitch*(1.0231))) {
      *which_octave = octave;
      //printf("found %d octave \n", octave);
      *deviation = (pitch - t->notepitches[i].pitch)/( t->notepitches[i].pitch*(pow(2,1.0/12.0)-1.0)/100.0) ;
      return &t->notepitches[i];
    }
  }

  return NULL;
}

/* look for a new note played into audio input, if
   present insert it into the score/store */
gint pitchentry(DenemoGUI *gui) {
  static gint last_step=-1, last_alteration, last_octave;
  if(PR_window==NULL)
    return FALSE;/* stops the timer */
  //  if(GTK_WIDGET_HAS_FOCUS (gui->scorearea))
  //return TRUE;

  double deviation;
  temperament *t = (temperament*)PR_temperament;
  gint octave;
  gdouble note = get_pitch();
  note *= transposition_required;

  if((note<highest_pitch) && (note>lowest_pitch))
   {
     //printf("Got a note %2.1f\n", note);
    notepitch *found = determine_note(note, t , &octave, &deviation);
    if(found) {
      if(!repeated_notes_allowed)
	if(found->spec.step==last_step &&
	   found->spec.alteration==last_alteration &&
	   (octave==last_octave || octave==last_octave-1)/* sometimes it jumps down an octave */) {
	  last_step=-1;
	  printf("Ignoring repeated note\n");
	  return TRUE;
	}
      
      last_step = found->spec.step;
      last_alteration = found->spec.alteration;
      last_octave = octave;


      int i;
      gchar *octstr=g_strdup("");
      for(i=0;i<octave;i++) {
	gchar *str = g_strdup_printf("%s%c",octstr,'\'');
	g_free(octstr);
	octstr=str;
      }
      for(i=0;i>octave;i--) {
	gchar *str = g_strdup_printf("%s%c",octstr,',');
	g_free(octstr);
	octstr=str;
      }

      //printf("note enshift %d %d\n",found->spec.step, found->spec.alteration );
      pr_display_note(gui, g_strdup_printf("%c%s%s",step_name(found->spec.step), alteration_name(found->spec.alteration), octstr));
      g_free(octstr);
      pr_display_pitch_deviation(gui, deviation);

      if(!PR_enable) {
	//printf("Enter the score area to insert notes!");
	return TRUE;
      }
      
      // Enter the note in the score
      if(PR_insert)
	enter_note_in_score(gui, found, octave);
      else
	enter_tone_in_store(gui, found, octave);
    }//note found
   } 

  return TRUE;
}




  // toggle PR_continuous advance to next measure or not
static void toggle_continuous(GtkButton *button, DenemoGUI *gui ) {
  PR_continuous = !PR_continuous;
}

static void change_silence(GtkSpinButton *widget, gpointer data){
  double silence = gtk_spin_button_get_value(widget);
  set_silence(silence);
}
static void change_threshold(GtkSpinButton *widget, gpointer data){
  double t = gtk_spin_button_get_value(widget);
  set_threshold(t);
}
static void change_smoothing(GtkSpinButton *widget, gpointer data){
  double m = gtk_spin_button_get_value(widget);
  set_smoothing(m);
}

static void change_onset_detection(GtkSpinButton *widget, gpointer data){
  guint m = gtk_spin_button_get_value(widget);
  set_onset_type(m);
}


static void change_lowest_pitch(GtkSpinButton *widget, gpointer data){
  lowest_pitch  = gtk_spin_button_get_value(widget);
}
static void change_highest_pitch(GtkSpinButton *widget, gpointer data){
  highest_pitch  = gtk_spin_button_get_value(widget);
}

static void change_greatest_interval(GtkSpinButton *widget, gpointer data){
  greatest_interval  = gtk_spin_button_get_value_as_int(widget);
}

static void change_transposition(GtkSpinButton *widget, gpointer data){
  gdouble power  = gtk_spin_button_get_value_as_int(widget);
  transposition_required = pow(2.0, power);
  printf("transposing = %f 2^1/12=%f\n", transposition_required, pow(2,1.0/12.0));
}

/* destroy PR_window, and hence terminate the pitch recog subsystem */
static void stop_PR_controls(void) {
  if(PR_window)
    gtk_widget_destroy(PR_window);
  PR_window = NULL;
}

/* stop the pitch recognition subsystem and optionally destroy the window
   that controls it */
static int stop_pitch_recognition_and_window(gboolean stop_window) {
  if(PR_gui==NULL)// when closing a second gui after the first has dismissed PR
    return;
  if(PR_timer)
    g_source_remove(PR_timer);
  //  if(PR_oldkeymap) // should always be true!
  //    PR_gui->prefs->the_keymap = PR_oldkeymap;
  if(PR_enter) 
    g_signal_handler_disconnect (PR_gui->scorearea, PR_enter);
  if(PR_leave) 
    g_signal_handler_disconnect (PR_gui->scorearea, PR_leave);
   PR_timer = PR_enter = PR_leave = 0;
  if(stop_window)
    stop_PR_controls();// which calls terminate_pitch_recognition 
  else
    terminate_pitch_recognition();
  PR_window = NULL;

  PR_gui = NULL;

  return 0;
}

static stop_pitch_recognition_callback(){
  stop_pitch_recognition_and_window(FALSE);
}




static void toggle_repeated_notes_allowed(){
  repeated_notes_allowed = !repeated_notes_allowed;
}

static void change_click_volume(GtkSpinButton *widget, DenemoGUI *gui){
  PR_click = (guint)gtk_spin_button_get_value(widget);
gtk_window_present(GTK_WINDOW(gui->window));
  //eventually make this value control the loudness of a click
}


static void change_timer_rate(GtkSpinButton *widget, DenemoGUI *gui){
  PR_time = (guint)gtk_spin_button_get_value(widget);
  start_pitch_recognition(gui);//FIXME do not call the whole of start_pitch_recognition, just the timer setting bit???
}


static void toggle_insert(GtkButton *button) {
  // switch the button to read Collect Notes/Insert Notes
  // toggle PR_insert to show where the notes detected should go
  PR_insert = !PR_insert;
  
}


static void create_pitch_recognition_window(DenemoGUI *gui) {
  GtkWidget *hbox, *hbox2;
  GtkWidget *button;
  GtkWidget *frame;
  GtkWidget *label;
  if(PR_window) {
    g_warning("unexpected call");
    return;
  }
  PR_window = gtk_window_new(GTK_WINDOW_TOPLEVEL);/* FIXME catch a destroy on this window
						   and turn off pitch detection, returning to unitialized state */

  gtk_window_set_title (GTK_WINDOW (PR_window), "Pitch Recognition Control");
  g_signal_connect (G_OBJECT (PR_window), "destroy",
		    G_CALLBACK (stop_pitch_recognition_callback), NULL); 
  GtkWidget *main_vbox = gtk_vbox_new (FALSE, 1);
  gtk_container_border_width (GTK_CONTAINER (main_vbox), 1);
  gtk_container_add (GTK_CONTAINER (PR_window), main_vbox);

  frame = gtk_frame_new( "Mode");
  gtk_container_add (GTK_CONTAINER (main_vbox), frame);
  hbox = gtk_hbox_new (FALSE, 1);
  gtk_container_add (GTK_CONTAINER (frame), hbox);

  frame = gtk_frame_new( "Overlay Pitches");
  gtk_container_add (GTK_CONTAINER (hbox), frame);

  GtkWidget *vbox2 = gtk_vbox_new (FALSE, 1);
  gtk_container_add (GTK_CONTAINER (frame), vbox2);

  hbox2 = gtk_hbox_new (FALSE, 1);

  gtk_box_pack_start (GTK_BOX (vbox2), hbox2,
		      TRUE, TRUE, 0);
  GtkWidget *radio_button = gtk_radio_button_new_with_label(NULL, "Overlay Pitches");
  gtk_box_pack_start (GTK_BOX (hbox2), radio_button,
		      TRUE, TRUE, 0);
  g_signal_connect (G_OBJECT (radio_button), "toggled",
		    G_CALLBACK (toggle_insert), NULL);

  button = gtk_button_new_with_label("Clear");
  gtk_box_pack_start (GTK_BOX (hbox2), button,
		      TRUE, TRUE, 0);
  g_signal_connect (G_OBJECT (button), "clicked",
		    G_CALLBACK (clear_tone_store), gui);
  hbox2 = gtk_hbox_new (FALSE, 1);

  gtk_box_pack_start (GTK_BOX (vbox2), hbox2,
		      TRUE, TRUE, 0);
  button = gtk_check_button_new_with_label("Continuous");
  gtk_box_pack_start (GTK_BOX (hbox2), button,
		      TRUE, TRUE, 0);
  PR_continuous = FALSE;
  g_signal_connect (G_OBJECT (button), "clicked",
		    G_CALLBACK (toggle_continuous), gui);


  label = gtk_label_new("Click Volume");
  gtk_box_pack_start (GTK_BOX (hbox2), label, TRUE, TRUE, 0);
  GtkAdjustment *spinner_adj =
    (GtkAdjustment *) gtk_adjustment_new (0.0, 0.0, 1.0,
					   1.0, 1.0, 1.0);
  GtkWidget *spinner = gtk_spin_button_new (spinner_adj, 1.0, 1);
  gtk_box_pack_start (GTK_BOX (hbox2), spinner, TRUE, TRUE, 0);
  g_signal_connect (G_OBJECT (spinner), "value-changed",
		    G_CALLBACK (change_click_volume), gui);




  button = gtk_radio_button_new_with_label_from_widget(radio_button, "Insert Notes");
  gtk_box_pack_start (GTK_BOX (hbox), button,
		      TRUE, TRUE, 0);/* no need for callback */



  frame = gtk_frame_new( "Enharmonic selection");
  gtk_container_add (GTK_CONTAINER (main_vbox), frame);
  hbox = gtk_hbox_new (FALSE, 1);
  gtk_container_add (GTK_CONTAINER (frame), hbox);
  label = gtk_label_new("");
  button = gtk_button_new_with_label("flatten");
  gtk_box_pack_start (GTK_BOX (hbox), button,
		      TRUE, TRUE, 0);
  g_signal_connect (G_OBJECT (button), "clicked",
		    G_CALLBACK (flatten), label);
  gchar *names = notenames(PR_temperament);
  
  gtk_label_set_markup(GTK_LABEL(label),names);
  g_free(names);
  gtk_box_pack_start (GTK_BOX (hbox), label,
		      TRUE, TRUE, 0);
  
  button = gtk_button_new_with_label("sharpen");
  gtk_box_pack_start (GTK_BOX (hbox), button,
		      TRUE, TRUE, 0);
  g_signal_connect (G_OBJECT (button), "clicked",
		    G_CALLBACK (sharpen), label);

  frame = gtk_frame_new( "Detected note");
  gtk_container_add (GTK_CONTAINER (main_vbox), frame);
  hbox = gtk_hbox_new (FALSE, 1);
  gtk_container_add (GTK_CONTAINER (frame), hbox);

  PR_notelabel = gtk_label_new("---");
  gtk_box_pack_start (GTK_BOX (hbox), PR_notelabel,
		      TRUE, TRUE, 0); 
  PR_deviation = gtk_label_new("0.0");
  gtk_box_pack_start (GTK_BOX (hbox), PR_deviation,
		      TRUE, TRUE, 0);
  /* spinners to select silence, threshold, smoothing */ 
  
  frame = gtk_frame_new( "Pitch Recognition Parameters");
  gtk_container_add (GTK_CONTAINER (main_vbox), frame);
  hbox = gtk_hbox_new (FALSE, 1);
  gtk_container_add (GTK_CONTAINER (frame), hbox);

  hbox2 =  gtk_hbox_new (FALSE, 1);
  gtk_box_pack_start (GTK_BOX (hbox), hbox2, TRUE, TRUE, 0);
  
  label = gtk_label_new("Silence");
  gtk_box_pack_start (GTK_BOX (hbox2), label, TRUE, TRUE, 0);
  spinner_adj =
    (GtkAdjustment *) gtk_adjustment_new (-90.0, -1000.0,
					  100.0, 10.0, 1.0, 1.0);
  spinner = gtk_spin_button_new (spinner_adj, 100.0, 0);
  gtk_box_pack_start (GTK_BOX (hbox), spinner, TRUE, TRUE, 0);
  g_signal_connect (G_OBJECT (spinner), "value-changed",
		    G_CALLBACK (change_silence), NULL);

  hbox2 =  gtk_hbox_new (FALSE, 1);
  gtk_box_pack_start (GTK_BOX (hbox), hbox2, TRUE, TRUE, 0);
  
  label = gtk_label_new("Threshold");
  gtk_box_pack_start (GTK_BOX (hbox2), label, TRUE, TRUE, 0);
  spinner_adj =
    (GtkAdjustment *) gtk_adjustment_new (0.3, 0.01,
					  100.0, 0.01, 1.0, 1.0);
  spinner = gtk_spin_button_new (spinner_adj, 0.5, 2);
  gtk_box_pack_start (GTK_BOX (hbox2), spinner, TRUE, TRUE, 0);
  g_signal_connect (G_OBJECT (spinner), "value-changed",
		    G_CALLBACK (change_threshold), NULL);

  hbox2 =  gtk_hbox_new (FALSE, 1);
  gtk_box_pack_start (GTK_BOX (hbox), hbox2, TRUE, TRUE, 0);
  
  label = gtk_label_new("Smoothing");
  gtk_box_pack_start (GTK_BOX (hbox2), label, TRUE, TRUE, 0);
  spinner_adj =
    (GtkAdjustment *) gtk_adjustment_new (6.0, 0.0,
					  100.0, 1.0, 1.0, 1.0);
  spinner = gtk_spin_button_new (spinner_adj, 0.5, 2);
  gtk_box_pack_start (GTK_BOX (hbox2), spinner, TRUE, TRUE, 0);
  g_signal_connect (G_OBJECT (spinner), "value-changed",
		    G_CALLBACK (change_smoothing), NULL);

  label = gtk_label_new("Onset");
  gtk_box_pack_start (GTK_BOX (hbox2), label, TRUE, TRUE, 0);
  spinner_adj =
    (GtkAdjustment *) gtk_adjustment_new (7.0, 0.0,
					  7.0, 1.0, 1.0, 1.0);
  spinner = gtk_spin_button_new (spinner_adj, 0.5, 2);
  gtk_box_pack_start (GTK_BOX (hbox2), spinner, TRUE, TRUE, 0);
  g_signal_connect (G_OBJECT (spinner), "value-changed",
		    G_CALLBACK (change_onset_detection), NULL);



  /* spinners to constrain the note values */


  frame = gtk_frame_new( "Note validation criteria");
  gtk_container_add (GTK_CONTAINER (main_vbox), frame);
  hbox = gtk_hbox_new (FALSE, 1);
  gtk_container_add (GTK_CONTAINER (frame), hbox);

  hbox2 =  gtk_hbox_new (FALSE, 1);
  gtk_box_pack_start (GTK_BOX (hbox), hbox2, TRUE, TRUE, 0);
  
  label = gtk_label_new("Lowest Pitch");
  gtk_box_pack_start (GTK_BOX (hbox2), label, TRUE, TRUE, 0);
  spinner_adj =
    (GtkAdjustment *) gtk_adjustment_new (DEFAULT_LOW, 60.0, 2080.0,
					   10.0, 1.0, 1.0);
  spinner = gtk_spin_button_new (spinner_adj, 100.0, 1);
  gtk_box_pack_start (GTK_BOX (hbox), spinner, TRUE, TRUE, 0);
  g_signal_connect (G_OBJECT (spinner), "value-changed",
		    G_CALLBACK (change_lowest_pitch), NULL);

  hbox2 =  gtk_hbox_new (FALSE, 1);
  gtk_box_pack_start (GTK_BOX (hbox), hbox2, TRUE, TRUE, 0);
  
  label = gtk_label_new("Highest Pitch");
  gtk_box_pack_start (GTK_BOX (hbox2), label, TRUE, TRUE, 0);
  spinner_adj =
    (GtkAdjustment *) gtk_adjustment_new (DEFAULT_HIGH, 120.0, 2400.0,
					   0.01, 1.0, 1.0);
  spinner = gtk_spin_button_new (spinner_adj, 100.0, 1);
  gtk_box_pack_start (GTK_BOX (hbox2), spinner, TRUE, TRUE, 0);
  g_signal_connect (G_OBJECT (spinner), "value-changed",
		    G_CALLBACK (change_highest_pitch), NULL);

  hbox2 =  gtk_hbox_new (FALSE, 1);
  gtk_box_pack_start (GTK_BOX (hbox), hbox2, TRUE, TRUE, 0);
  
  label = gtk_label_new("Greatest Interval");
  gtk_box_pack_start (GTK_BOX (hbox2), label, TRUE, TRUE, 0);
  spinner_adj =
    (GtkAdjustment *) gtk_adjustment_new (8.0, 1.0,
					  15.0, 1.0, 1.0, 1.0);
  spinner = gtk_spin_button_new (spinner_adj, 1.0, 0);
  gtk_box_pack_start (GTK_BOX (hbox2), spinner, TRUE, TRUE, 0);
  g_signal_connect (G_OBJECT (spinner), "value-changed",
		    G_CALLBACK (change_greatest_interval), NULL);

  /* options */

 frame = gtk_frame_new( "Input handling");
  gtk_container_add (GTK_CONTAINER (main_vbox), frame);
  hbox = gtk_hbox_new (FALSE, 1);
  gtk_container_add (GTK_CONTAINER (frame), hbox);


  
  label = gtk_check_button_new_with_label("Disable repeated notes");
  gtk_box_pack_start (GTK_BOX (hbox), label, TRUE, TRUE, 0);
  g_signal_connect (G_OBJECT (label), "clicked",
		    G_CALLBACK (toggle_repeated_notes_allowed), NULL);
  label = gtk_label_new("Transpose Input");
  gtk_box_pack_start (GTK_BOX (hbox), label, TRUE, TRUE, 0);
  spinner_adj =
    (GtkAdjustment *) gtk_adjustment_new (0.0, -3.0,
					  3.0, 1.0, 1.0, 1.0);
  spinner = gtk_spin_button_new (spinner_adj, 1.0, 0);
  gtk_box_pack_start (GTK_BOX (hbox), spinner, TRUE, TRUE, 0);
  g_signal_connect (G_OBJECT (spinner), "value-changed",
		    G_CALLBACK (change_transposition), NULL);

  label = gtk_label_new("Delay");
  gtk_box_pack_start (GTK_BOX (hbox), label, TRUE, TRUE, 0);
  spinner_adj =
    (GtkAdjustment *) gtk_adjustment_new (DEFAULT_TIMER_RATE, 1.0,
					  500.0, 10.0, 1.0, 1.0);
  spinner = gtk_spin_button_new (spinner_adj, 10.0, 0);
  gtk_box_pack_start (GTK_BOX (hbox), spinner, TRUE, TRUE, 0);
  g_signal_connect (G_OBJECT (spinner), "value-changed",
		    G_CALLBACK (change_timer_rate), gui);

/* now show the window, but leave the main window with the focus */
  gtk_window_set_focus_on_map((GtkWindow *)PR_window, FALSE);
  gtk_widget_show_all(PR_window);
  gtk_window_set_focus((GtkWindow*)PR_window, NULL);
  gtk_widget_grab_focus(gui->scorearea);
  
}


gint setup_pitch_recognition(DenemoGUI *gui){
  if(PR_window) {
    gtk_window_present(GTK_WINDOW(PR_window));
    return 0;
  }
  if(PR_temperament==NULL)
    PR_temperament = default_temperament();
  if(initialize_pitch_recognition()==0) {
    set_silence(-90.0);
    set_threshold(0.3);
    set_smoothing(6.0);
    transposition_required = 1.0;
    lowest_pitch = DEFAULT_LOW;
    highest_pitch = DEFAULT_HIGH;
    repeated_notes_allowed = TRUE;
    create_pitch_recognition_window(gui);
    //read_PRkeymap(gui);
    return 0;
  } else
    return -1;
}



/* stop_pitch_recognition
   stop audio and aubio
   param STOP_WINDOW means destroy the PR_window, otherwise it is
   being called from the destroy callback of PR_window itself */
int stop_pitch_recognition(void) {
  return stop_pitch_recognition_and_window(TRUE);

}

static void 
scorearea_set_active(GtkWidget *widget, GdkEventCrossing *event, DenemoGUI *gui) {
  PR_enable = TRUE; 
  gtk_widget_draw(gui->scorearea, NULL);
}
static void 
scorearea_set_inactive(GtkWidget *widget, GdkEventCrossing *event, DenemoGUI *gui) {
  PR_enable = FALSE; 
  gtk_widget_draw(gui->scorearea, NULL);
}
void start_pitch_recognition(DenemoGUI *gui) { 
  if(PR_timer)
    g_source_remove(PR_timer);

  PR_timer = g_timeout_add (PR_time, (GSourceFunc)pitchentry, gui);
  if(PR_timer==0)
    g_error("Timer id 0 - if valid the code needs re-writing (documentation not clear)");
  gtk_widget_add_events (gui->scorearea, GDK_LEAVE_NOTIFY_MASK | GDK_ENTER_NOTIFY_MASK);
  PR_enter = g_signal_connect (G_OBJECT (gui->scorearea), "enter-notify-event",
			       G_CALLBACK (scorearea_set_active), (gpointer)gui);
  PR_leave = g_signal_connect (G_OBJECT (gui->scorearea), "leave-notify-event",
			       G_CALLBACK (scorearea_set_inactive), (gpointer)gui);
  PR_gui = gui;
}

gboolean pitch_recognition_system_active(void) {
  return PR_window!=NULL;
}

gboolean pitch_entry_active(DenemoGUI *gui) {
  return (PR_gui == gui) && PR_enable;
}

