<?xml version="1.0"?>
<Denemo>
  <merge>
    <title>A Denemo Keymap</title>
    <author>AT, JRR, RTS</author>
    <map>
      <row>
        <after>ToggleImmediatePlayback</after>
        <action>ConvertMidiForBass</action>
        <scheme>;;;;;;;; DenemoConvertFromBass

(define (DenemoConvertFromBass)
(define MidiNoteStarts (make-vector 256 #f))
(defstruct note name start duration)
(define Notes '())

(if (d-RewindRecordedMidi)
    (let loop ((note #f)(tick 0))
      (set! note (d-GetRecordedMidiNote))
      (if note
	  (begin
	    (set! tick (d-GetRecordedMidiOnTick))
	    (if (&lt; tick 0)
		(let ((on (vector-ref MidiNoteStarts note)))
		  (if on
		      (begin 
			(set! Notes (cons (list (make-note 'name note 'start on 'duration (- (- tick) on))) Notes))
			(vector-set! MidiNoteStarts note #f)	
			(loop note tick))
		      (format #t "An off with no On\n")))
		(let ((on (vector-ref MidiNoteStarts note)))
		  (if on
		      (format #t "An on when already on\n")
		      (begin
			(vector-set! MidiNoteStarts note tick)
			(loop note tick)
		)))))
	  (begin         ;;;;;; finished generating Notes as a list of lists each with one note struct in it
	    (if (&gt; (length Notes) 0)
		(let ()
;;;;;;; we have at least one note in the Notes list, define to procs to create a denemo chord and add a note to it
		    (define (add-note note)
		      (if (note? note)
			  (begin
			  (eval-string (string-append "(d-InsertNoteInChord \"" (d-GetNoteForMidiKey (note.name note)) "\")")))
			  (format #t "\tNo note to add note ~a ~a to\n" (note.name note) (note.duration note))))
		    
		    (define (insert-note name dur)
		      (let ((base (duration::GuessBaseNoteInTicks dur)))
			(format #t "have ~a ~a \n" base dur)
			(if base
			    (begin
			      (if (&gt; (- dur base) (- (* 2 base) dur))
				  (set! base (* base 2)))
			      (begin 
				;(format #t "Create note ~a ~a\n"  (d-GetNoteForMidiKey name)   (duration::ticks-&gt;denemo base))
				(eval-string (string-append  "(d-Insert" (duration::ticks-&gt;denemo base)")"))
				(d-PutNoteName (d-GetNoteForMidiKey name)))))))
;;;;;;;;;;;;;; end of defining procs
		    
;;; notes has been set up by pre-pending so it is backwards...	    
		    (set! Notes (reverse Notes))
     
                    ;;;;;; take the Notes and seek out bass notes, remove them and form chords, insert chords in staff above
		    (let () ;;;no loop here we drive it via the loopforbasskey
                      ;;;;;;;;;;; overlap decides if two notes should be a chord	 
		      (define (overlap n1 n2)
			(if (list? n1)
			    (set! n1 (car n1)))
			(&lt; (abs (- (note.start n1) (note.start n2))) 50))
                      ;;;;;;;;;;;;;;;;;; end of overlap
		      
					;(format #t "Number of notes ~a\n" index)

                      ;;;;;;;Step through notes in current (bass) staff, placing chords in (empty) staff above
		    
				(let loopforbasskey ()

;;;;;;;;;;;;; copy non-notes to the empty staff above and stop with the cursor on the first bass note
				(let loop ()
                                  ;;;;first copy anything that are not a bass note to the staff above
				  (if (or (Rest?) (Tupletmarker?))
				      (begin 
					(d-SetMark) (d-Copy) (d-PushPosition)(d-MoveToStaffUp) (GoToMeasureEnd)(d-Paste)(d-PopPosition))
				      (begin
					(if (and (not (Note?)) (d-NextObject))
					    (loop)))))

;;;;;;;;;;;;; cursor is on the first/next bass note (if any)
				(if (Note?)  
				    (let  ((bass-key (d-GetNoteAsMidi)) (bass-duration (d-GetDurationInTicks))) ;;;midi number and duration of current note
				      ;; now loop through the Notes list looking for a note the same MIDI key number, which should be before ticks move on too much... once found, consecutive notes are taken to make a chord or chords for the bass note, an
				      (define notes-belonging '());the notes belonging to the bass note
				      (define bass-note #f);a bass note (list) selected from Notes

;;;;;;;;;;;;;;;;;; three procs: make-chords takes a list which has each note in a separate list and puts all the (consecutive) ones that overlap into a single list, that is it turns a sequence of list-of-note into a list-of-notes which represents a chord. It returns the list.
		      
				      (define (make-chords notes)
(disp "make-chords with " notes "\n")
					(let loop ((index 0))
					  (disp "Now looping with index " index "and notes " notes "\n")
					  (let ((note1 (list-ref notes index))
						(note2 #f))
					    (if (&gt; (length notes) (+ 1 index))
						(begin
						  (set! note2 (list-ref notes (+ 1 index)))
						  (if (overlap note1 (car note2))
						      (begin
							(list-set! notes index (cons (car note2) note1))
	(disp "notes is" notes "\nwe will delete " note2 "\n") ;;at this point note2 is in the chord and in the list
							(set! notes (delq note2 notes)) ;;so we loop with same index
							(disp "notes has become" notes "\n")
							)
						      (set! index (+ 1 index)))
						  (loop index)))))
						  (disp "and so we return " notes "\n")
					notes)	
;;;;;;; insert-chord takes a list of note structs and puts a chord in the staff above with those notes.		
				      (define (insert-chord chord duration)
						(insert-note (note.name (car chord)) duration)
							(for-each  add-note (cdr chord)))

;;;;;;; insert-chords takes a list of lists of note structs and the duration of the denemo bass note they have been assigned to. It inserts a chord for each of the lists assigning durations to fit the bass note.		
				      (define (insert-chords notes bass-duration)
(disp "insert-chords called with " notes "\n")				   
					(let ((chords (make-chords notes)))
				    ;;;loop through the chords, getting a good duration value, the duration from one to the next and inserting
					  (let loop ((index 0))
(disp "length " (length chords) "\n")
					    (if (&gt; (length chords) (+ 1 index))
						(let ((chord1 (list-ref chords index))
						      (chord2 #f)
						      (duration #f))
						 
							(set! chord2 (list-ref chords (+ 1 index)))
							(set! duration (- (note.start (car chord2)) (note.start (car chord1))))
							(format #t "With duration ~a\n" duration)
							(insert-chord chord1 duration)
							(loop (+ index 1)))	     
						(begin
						  (if (= (length chords) 1)
						     (insert-chord (list-ref chords 0) bass-duration)
						     (d-WarningDialog "We have no chord")))))))
;;;;;;;;;;;;;;;;;;;;;;;;; now the actual processing to loop through Notes finding an equivalent to bass-key and processing the notes belong. These are removed from Notes and then the outer loop to move on in the bass staff is taken.				      

;;; first loop through Notes from the start (previous chords have been deleted) and seek the bass-note				      
					(let loopgetbassnote ((index 0))
(disp "now index " index "bass-key " bass-key "\n")
					  (if (&gt; (length Notes) index)
						 (if (= bass-key (note.name (car (list-ref Notes index))))
						     (begin
						       (disp "started " index " with " Notes "\n")
						       (set! bass-note (list-ref Notes index))
						       (set! Notes (delq bass-note Notes))
						       (disp "removed " bass-note "from Notes\n")
						       (disp "now " Notes "\n")
						       )
						     (loopgetbassnote (+ index 1)))))
                                           ;;;; if bass-note then that note should have been removed from Notes, next get chord notes
                                        (set! notes-belonging '())
					(if bass-note					    
					      (let loop ((index 0))
						(if (&gt; (length Notes) index)
						    (let ( (next-note (list-ref Notes index)))
						    (disp "next note is " next-note "\n should not be" (eq? next-note bass-note) "otherwise bass note is still there at " index "\n")
						    (if (overlap bass-note (car next-note))
							(begin
							  (set! notes-belonging (cons*  next-note notes-belonging))
							  (set! Notes (delq next-note Notes))
							  (loop index)))))))
;;;;;;;;;;;;;;;;;;; finished creating notes-belonging, all these notes are now removed from Notes
					      
					     
					      (if (&gt; (length notes-belonging) 0)
						  (begin
						    (d-PushPosition)
						    (d-StaffUp)
						    (GoToMeasureEnd)
(disp "notes-belonging looks like this: " notes-belonging "\n")
						    (insert-chords notes-belonging bass-duration)
(disp "insert-chords finished\n")
						    (d-PopPosition)
                                                    (if (d-NextObject)
							(loopforbasskey)
						    (d-WarningDialog "finished bass staff")))
						  
						  (begin
						  (d-WarningDialog "found no notes for a bass-note")
						  (disp "Bass note with no accompanying chord" bass-note))));;;if there is a note in the bass clef



					    (d-WarningDialog "No more bass notes")))))

		(begin
		  (d-WarningDialog "The Notes list is empty"))))))
				    
	
		(format #t "No notes found in recording\n")))

(DenemoConvertFromBass)
;;;;;;;;;;;;;;;;;;;;;;;;</scheme>
        <label>Convert MIDI chords over Bass</label>
        <tooltip>Takes a MIDI recording over a bass line and inserts the chords by matching the bass notes. Each chord must include the bass note.</tooltip>
      </row>
    </map>
  </merge>
</Denemo>
